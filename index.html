<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yama Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #ff6b35;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .strategies {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 5px;
        }
        
        .strategy-label {
            color: #aaa;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .strategy-btn {
            padding: 8px 16px;
            font-size: 14px;
            background: #555;
            color: white;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .strategy-btn.active {
            background: #ff6b35;
            border-color: #ff6b35;
        }
        
        .strategy-btn:hover {
            opacity: 0.8;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #ff8555;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 200px;
        }
        
        .stats {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-box {
            background: #333;
            padding: 15px;
            border-radius: 5px;
        }
        
        .stat-label {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b35;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        .timeline-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
        }
        
        .cumulative-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: 1fr 200px;
            gap: 20px;
        }
        
        .cumulative-left {
            display: flex;
            flex-direction: column;
        }
        
        .cumulative-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
            color: #ff6b35;
        }
        
        .cumulative-chart {
            height: 500px;
            background: #1a1a1a;
            border-radius: 5px;
        }
        
        .cumulative-table {
            background: #1a1a1a;
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            max-height: 540px;
        }
        
        .table-title {
            font-size: 14px;
            font-weight: bold;
            color: #ff6b35;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .table-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 5px;
            font-size: 12px;
            border-bottom: 1px solid #333;
        }
        
        .table-row:last-child {
            border-bottom: none;
        }
        
        .table-header {
            font-weight: bold;
            color: #aaa;
        }
        
        .side-histograms {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 20px;
        }
        
        .histogram-box.large {
            grid-column: span 3;
        }
        
        .histogram-box.small {
            grid-column: span 2;
        }
        
        .timeline {
            position: relative;
            min-width: 1500px;
        }
        
        .health-chart {
            position: relative;
            height: 200px;
            margin-bottom: 20px;
            background: #1a1a1a;
            border-radius: 5px;
        }
        
        canvas {
            display: block;
        }
        
        .timeline-grid {
            position: relative;
            background-image: repeating-linear-gradient(
                to right,
                transparent,
                transparent 4px,
                #2a2a2a 4px,
                #2a2a2a 5px
            );
        }
        
        .axis {
            display: flex;
            position: relative;
            height: 30px;
            border-top: 2px solid #555;
            margin-bottom: 5px;
        }
        
        .axis-label {
            position: absolute;
            font-size: 10px;
            color: #888;
            transform: translateX(-50%);
        }
        
        .time-axis {
            opacity: 0.5;
            margin-top: -5px;
        }
        
        .damage-row {
            position: relative;
            height: 40px;
            border-top: 1px solid #444;
            margin-bottom: 10px;
        }
        
        .row-label {
            position: absolute;
            left: -120px;
            top: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #aaa;
        }
        
        .damage-block {
            position: absolute;
            height: 30px;
            top: 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: white;
            border: 1px solid rgba(0,0,0,0.3);
        }
        
        .phase-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            border-left: 2px dashed #ff6b35;
            pointer-events: none;
        }
        
        .phase-label {
            position: absolute;
            top: -20px;
            left: 5px;
            font-size: 12px;
            color: #ff6b35;
            font-weight: bold;
        }
        
        .histograms {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .histogram-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 10px;
        }
        
        .histogram-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: #ff6b35;
        }
        
        .histogram {
            height: 150px;
            background: #1a1a1a;
            border-radius: 5px;
        }
        
        .histogram.large {
            height: 350px;
        }
        
        .histogram.cumulative {
            height: 300px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>OSRS Yama Boss Fight Simulator</h1>
        
        <div class="controls">
            <button id="startBtn">Start Simulation</button>
            <div class="slider-container">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="1" max="300" value="10">
                <span id="speedValue">10</span> sims/sec
            </div>
            <div class="strategies">
                <span class="strategy-label">Strategies:</span>
                <button class="strategy-btn" id="strategyDClaw">D Claw</button>
                <button class="strategy-btn" id="strategyTickFill">Tick Fill Scythe</button>
                <button class="strategy-btn" id="strategyZCB">ZCB</button>
                <button class="strategy-btn" id="strategyTorva">Torva</button>
                <button class="strategy-btn" id="strategyZCB9">ZCB 9</button>
                <button class="strategy-btn" id="strategyZCB10">ZCB 10</button>
                <button class="strategy-btn" id="strategyZCB11">ZCB 11</button>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-label">Simulations Run</div>
                <div class="stat-value" id="simCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Average Time</div>
                <div class="stat-value" id="avgTime">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Best Time</div>
                <div class="stat-value" id="bestTime">-</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Current Time</div>
                <div class="stat-value" id="currentTime">-</div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="timeline-container">
                <div class="timeline">
                    <div class="health-chart">
                        <canvas id="healthCanvas"></canvas>
                    </div>
                    <div class="timeline-grid" id="timelineGrid">
                        <!-- Timeline will be generated here -->
                    </div>
                </div>
            </div>
            
            <div class="cumulative-container">
                <div class="cumulative-left">
                    <div class="cumulative-title">Cumulative Distribution - Chance to Achieve Time or Faster</div>
                    <canvas id="cumulativeChart" class="cumulative-chart"></canvas>
                </div>
                <div class="cumulative-table" id="cumulativeTable">
                    <div class="table-title">Chance per Tick</div>
                    <div class="table-row table-header">
                        <div>Ticks</div>
                        <div>Chance</div>
                    </div>
                </div>
            </div>
            
            <div class="side-histograms">
                <div class="histogram-box large">
                    <div class="histogram-title">Overall Distribution</div>
                    <canvas id="mainHistogram" class="histogram large"></canvas>
                </div>
                <div class="histogram-box large">
                    <div class="histogram-title">Sub 2:00 Phase 1</div>
                    <canvas id="sub200Phase1Histogram" class="histogram large"></canvas>
                </div>
                <div class="histogram-box small">
                    <div class="histogram-title">Phase 1</div>
                    <canvas id="phase1Histogram" class="histogram"></canvas>
                </div>
                <div class="histogram-box small">
                    <div class="histogram-title">Phase 2</div>
                    <canvas id="phase2Histogram" class="histogram"></canvas>
                </div>
                <div class="histogram-box small">
                    <div class="histogram-title">Phase 3</div>
                    <canvas id="phase3Histogram" class="histogram"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const TICK_WIDTH = 5;
        const MAX_TICKS = 300;
        
        // Weapon definitions
        const WEAPONS = {
            EMBER: { maxHit: 68, p1Acc: 0.83, p3Acc: 0.7969, duration: 4, color: '#e74c3c' },
            SWIFT: { maxHit: 34, p1Acc: 0.5591, p3Acc: 0.4748, duration: 3, color: '#4ecdc4' },
            ELDER_MAUL: { maxHit: 68, p1Acc: 1.0, p3Acc: 1.0, duration: 6, color: '#2c3e50' },
            EYE_OF_AYAK: { maxHit: 35, p1Acc: 1.0, p3Acc: 1.0, duration: 3, color: '#3498db' },
            SPEAR: { maxHit: 200, p1Acc: 1.0, p3Acc: 1.0, duration: 5, color: '#00008B' },
            SCYTHE: { maxHit: [50, 25, 12], p1Acc: 0.7177, p3Acc: 0.6628, duration: 5, color: '#5a6c7d' },
            BURNING_CLAW: { maxHit: 50, p1Acc: 0.83, p3Acc: 0.70, duration: 4, color: '#e67e22' },
            ZCB: { maxHit: 110, p1Acc: 0.066, p3Acc: 0.066, duration: 5, color: '#9b59b6' },
            ZCB_P1: { maxHit: 110, p1Acc: 1.0, p3Acc: 1.0, duration: 5, color: '#9b59b6' },
            DRAGON_CLAW: { maxHit: 45, p1Acc: 0.5475, p3Acc: 0.5475, duration: 4, color: '#8B0000' }
        };
        
        // State
        let isRunning = false;
        let simulationInterval = null;
        let simCount = 0;
        let allTimes = [];
        let phase1Times = [];
        let phase2Times = [];
        let phase3Times = [];
        let phase1Gates = [];
        let phase2Gates = [];
        let sub200Phase1Gates = [];
        let healthLines = [];
        
        // Strategy state
        let strategies = {
            dClaw: false,
            tickFillScythe: false,
            zcb: false,
            torva: false,
            zcb9: false,
            zcb10: false,
            zcb11: false
        };
        
        // Elements
        const startBtn = document.getElementById('startBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const healthCanvas = document.getElementById('healthCanvas');
        const healthCtx = healthCanvas.getContext('2d');
        
        // Setup canvas
        healthCanvas.width = TICK_WIDTH * MAX_TICKS;
        healthCanvas.height = 200;
        
        // Event listeners
        startBtn.addEventListener('click', toggleSimulation);
        speedSlider.addEventListener('input', (e) => {
            speedValue.textContent = e.target.value;
            if (isRunning) {
                stopSimulation();
                startSimulation();
            }
        });
        
        // Strategy buttons
        document.getElementById('strategyDClaw').addEventListener('click', function() {
            strategies.dClaw = !strategies.dClaw;
            this.classList.toggle('active');
        });
        
        document.getElementById('strategyTickFill').addEventListener('click', function() {
            strategies.tickFillScythe = !strategies.tickFillScythe;
            this.classList.toggle('active');
        });
        
        document.getElementById('strategyZCB').addEventListener('click', function() {
            strategies.zcb = !strategies.zcb;
            this.classList.toggle('active');
        });
        
        document.getElementById('strategyTorva').addEventListener('click', function() {
            strategies.torva = !strategies.torva;
            this.classList.toggle('active');
            updateWeaponStats();
        });
        
        document.getElementById('strategyZCB9').addEventListener('click', function() {
            strategies.zcb9 = !strategies.zcb9;
            this.classList.toggle('active');
            // Disable other ZCB strategies
            if (strategies.zcb9) {
                strategies.zcb10 = false;
                strategies.zcb11 = false;
                document.getElementById('strategyZCB10').classList.remove('active');
                document.getElementById('strategyZCB11').classList.remove('active');
            }
        });
        
        document.getElementById('strategyZCB10').addEventListener('click', function() {
            strategies.zcb10 = !strategies.zcb10;
            this.classList.toggle('active');
            // Disable other ZCB strategies
            if (strategies.zcb10) {
                strategies.zcb9 = false;
                strategies.zcb11 = false;
                document.getElementById('strategyZCB9').classList.remove('active');
                document.getElementById('strategyZCB11').classList.remove('active');
            }
        });
        
        document.getElementById('strategyZCB11').addEventListener('click', function() {
            strategies.zcb11 = !strategies.zcb11;
            this.classList.toggle('active');
            // Disable other ZCB strategies
            if (strategies.zcb11) {
                strategies.zcb9 = false;
                strategies.zcb10 = false;
                document.getElementById('strategyZCB9').classList.remove('active');
                document.getElementById('strategyZCB10').classList.remove('active');
            }
        });
        
        // Initialize timeline
        initializeTimeline();
        
        function updateWeaponStats() {
            if (strategies.torva) {
                WEAPONS.EMBER.maxHit = 69;
                WEAPONS.EMBER.p1Acc = 0.8076;
                WEAPONS.EMBER.p3Acc = 0.7702;
            } else {
                WEAPONS.EMBER.maxHit = 68;
                WEAPONS.EMBER.p1Acc = 0.83;
                WEAPONS.EMBER.p3Acc = 0.7969;
            }
        }
        
        function initializeTimeline() {
            const grid = document.getElementById('timelineGrid');
            grid.innerHTML = '';
            
            // Create tick axis
            const tickAxis = document.createElement('div');
            tickAxis.className = 'axis';
            for (let i = 0; i <= MAX_TICKS; i += 30) {
                const label = document.createElement('div');
                label.className = 'axis-label';
                label.style.left = (i * TICK_WIDTH) + 'px';
                label.textContent = i;
                tickAxis.appendChild(label);
            }
            grid.appendChild(tickAxis);
            
            // Create time axis (mm:ss)
            const timeAxis = document.createElement('div');
            timeAxis.className = 'axis time-axis';
            for (let i = 0; i <= MAX_TICKS; i += 50) {
                const seconds = i * 0.6;
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const label = document.createElement('div');
                label.className = 'axis-label';
                label.style.left = (i * TICK_WIDTH) + 'px';
                label.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
                timeAxis.appendChild(label);
            }
            grid.appendChild(timeAxis);
            
            // Create damage rows
            const rows = ['Player 1', 'Player 2', 'Thralls', 'Venge', 'Yama Attacks'];
            rows.forEach(rowName => {
                const row = document.createElement('div');
                row.className = 'damage-row';
                row.id = `row-${rowName.toLowerCase().replace(' ', '-')}`;
                const label = document.createElement('div');
                label.className = 'row-label';
                label.textContent = rowName;
                row.appendChild(label);
                grid.appendChild(row);
            });
        }
        
        function toggleSimulation() {
            if (isRunning) {
                stopSimulation();
            } else {
                startSimulation();
            }
        }
        
        function startSimulation() {
            isRunning = true;
            startBtn.textContent = 'Stop Simulation';
            const speed = parseInt(speedSlider.value);
            const interval = 1000 / speed;
            simulationInterval = setInterval(runSimulation, interval);
        }
        
        function stopSimulation() {
            isRunning = false;
            startBtn.textContent = 'Start Simulation';
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
        }
        
        function runSimulation() {
            const result = simulateFight();
            simCount++;
            allTimes.push(result.totalTicks);
            phase1Times.push(result.phase1Ticks);
            phase2Times.push(result.phase2Ticks);
            phase3Times.push(result.phase3Ticks);
            phase1Gates.push(result.phase1Gates);
            phase2Gates.push(result.phase2Gates);
            
            // Track sub-200 phase 1 gates
            if (result.totalTicks <= 199) {
                sub200Phase1Gates.push(result.phase1Gates);
            }
            
            updateStats(result);
            renderTimeline(result);
            renderHealthChart(result);
            updateHistograms();
        }
        
        function simulateFight() {
            // Determine red/blue order (shared across phase 1 and 2)
            const redFirst = Math.random() < 0.5;
            const blueIsOrb = redFirst && Math.random() < 0.5;
            
            let currentTick = 0;
            let yamaHP = 2500;
            const attacks = [];
            const healthHistory = [{tick: 0, hp: 2500}];
            
            // Phase 1
            const phase1Result = simulatePhase1(redFirst, blueIsOrb, currentTick, yamaHP, attacks, healthHistory);
            currentTick = phase1Result.endTick;
            yamaHP = phase1Result.yamaHP;
            const phase1Ticks = phase1Result.phaseTicks;
            
            // Judge Phase 1
            const judge1Result = simulateJudgePhase(currentTick, attacks);
            currentTick = judge1Result.endTick;
            
            // Phase 2
            const phase2Result = simulatePhase2(redFirst, blueIsOrb, currentTick, yamaHP, attacks, healthHistory);
            currentTick = phase2Result.endTick;
            yamaHP = phase2Result.yamaHP;
            const phase2Ticks = phase2Result.phaseTicks;
            
            // Judge Phase 2
            const judge2Result = simulateJudgePhase(currentTick, attacks);
            currentTick = judge2Result.endTick;
            
            // Phase 3
            const phase3Result = simulatePhase3(currentTick, yamaHP, attacks, healthHistory);
            currentTick = phase3Result.endTick;
            const phase3Ticks = phase3Result.phaseTicks;
            
            return {
                totalTicks: currentTick,
                phase1Ticks,
                phase2Ticks,
                phase3Ticks,
                phase1Gates: phase1Result.gates,
                phase2Gates: phase2Result.gates,
                attacks,
                healthHistory,
                phases: {
                    phase1End: phase1Result.endTick,
                    judge1End: judge1Result.endTick,
                    phase2End: phase2Result.endTick,
                    judge2End: judge2Result.endTick,
                    phase3End: phase3Result.endTick
                }
            };
        }
        
        function simulatePhase1(redFirst, blueIsOrb, startTick, startHP, attacks, healthHistory) {
            let globalTick = startTick;
            let phaseTick = 0;
            let yamaHP = startHP;
            
            // Player attacks start on tick 6
            let p1Tick = 6;
            let p2Tick = 6;
            let thrallTick = 8;
            
            // Venge ticks
            const vengeTicks = [25, 49];
            let vengeIndex = 0;
            
            // Yama attacks start on tick 11
            let yamaAttackTick = 11;
            let yamaAttackCount = 0;
            
            // Player 1: Elder Maul, then Burning Claws (1 if D Claw, 2 otherwise), then Embers (or ZCB first if strategy, or special ZCB 9/10/11 schedule)
            let p1AttackIndex = 0;
            let p1Attacks;
            
            if (strategies.zcb9) {
                // ZCB 9: Maul, 7 embers, guaranteed ZCB, then embers
                p1Attacks = ['ELDER_MAUL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'ZCB_P1'];
            } else if (strategies.zcb10) {
                // ZCB 10: Maul, 8 embers, guaranteed ZCB, then embers
                p1Attacks = ['ELDER_MAUL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'ZCB_P1'];
            } else if (strategies.zcb11) {
                // ZCB 11: Maul, 9 embers, guaranteed ZCB, then embers
                p1Attacks = ['ELDER_MAUL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'ZCB_P1'];
            } else if (strategies.zcb) {
                p1Attacks = strategies.dClaw ? ['ZCB_P1', 'ELDER_MAUL', 'BURNING_CLAW'] : ['ZCB_P1', 'ELDER_MAUL', 'BURNING_CLAW', 'BURNING_CLAW'];
            } else {
                p1Attacks = strategies.dClaw ? ['ELDER_MAUL', 'BURNING_CLAW'] : ['ELDER_MAUL', 'BURNING_CLAW', 'BURNING_CLAW'];
            }
            
            // Add scythes for tick fill strategy (if not ZCB 9/10/11)
            if (strategies.tickFillScythe && !strategies.zcb && !strategies.zcb9 && !strategies.zcb10 && !strategies.zcb11) {
                p1Attacks = strategies.dClaw ? ['ELDER_MAUL', 'BURNING_CLAW', 'SCYTHE'] : ['ELDER_MAUL', 'BURNING_CLAW', 'BURNING_CLAW', 'SCYTHE'];
            } else if (strategies.tickFillScythe && strategies.zcb && !strategies.zcb9 && !strategies.zcb10 && !strategies.zcb11) {
                p1Attacks = strategies.dClaw ? ['ZCB_P1', 'ELDER_MAUL', 'BURNING_CLAW', 'SCYTHE'] : ['ZCB_P1', 'ELDER_MAUL', 'BURNING_CLAW', 'BURNING_CLAW', 'SCYTHE'];
            }
            
            // Player 2: Special ember (100% dmg), 3 claws, then regular Embers (or ZCB first if strategy, or special ZCB 9/10/11 schedule)
            let p2AttackIndex = 0;
            let p2Attacks;
            
            if (strategies.zcb9) {
                // ZCB 9: Special ember, 7 embers, wait 2 ticks, guaranteed ZCB, then embers
                p2Attacks = ['EMBER_SPECIAL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'WAIT', 'WAIT', 'ZCB_P1'];
            } else if (strategies.zcb10) {
                // ZCB 10: Special ember, 8 embers, wait 2 ticks, guaranteed ZCB, then embers
                p2Attacks = ['EMBER_SPECIAL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'WAIT', 'WAIT', 'ZCB_P1'];
            } else if (strategies.zcb11) {
                // ZCB 11: Special ember, 9 embers, wait 2 ticks, guaranteed ZCB, then embers
                p2Attacks = ['EMBER_SPECIAL', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'EMBER', 'WAIT', 'WAIT', 'ZCB_P1'];
            } else if (strategies.zcb) {
                p2Attacks = ['ZCB', 'EMBER_SPECIAL', 'BURNING_CLAW', 'BURNING_CLAW', 'BURNING_CLAW'];
            } else {
                p2Attacks = ['EMBER_SPECIAL', 'BURNING_CLAW', 'BURNING_CLAW', 'BURNING_CLAW'];
            }
            
            // Add scythes for tick fill strategy (if not ZCB 9/10/11)
            if (strategies.tickFillScythe && !strategies.zcb && !strategies.zcb9 && !strategies.zcb10 && !strategies.zcb11) {
                p2Attacks = ['EMBER_SPECIAL', 'BURNING_CLAW', 'BURNING_CLAW', 'BURNING_CLAW', 'SCYTHE', 'SCYTHE', 'SCYTHE'];
            } else if (strategies.tickFillScythe && strategies.zcb && !strategies.zcb9 && !strategies.zcb10 && !strategies.zcb11) {
                p2Attacks = ['ZCB', 'EMBER_SPECIAL', 'BURNING_CLAW', 'BURNING_CLAW', 'BURNING_CLAW', 'SCYTHE', 'SCYTHE', 'SCYTHE'];
            }
            
            let phaseEnding = false;
            let phaseTick_final = -1;
            
            for (let i = 0; i < 200; i++) {
                phaseTick = i;
                globalTick = startTick + i;
                
                // Check for Yama attack tick
                if (phaseTick === yamaAttackTick) {
                    // Only add the attack if we haven't reached the phase tick
                    if (!phaseEnding || phaseTick < phaseTick_final) {
                        const attackType = yamaAttackCount === 0 ? 'Auto' : (yamaAttackCount === 1 || yamaAttackCount === 5) ? 'Special' : 'Auto';
                        attacks.push({
                            type: 'YAMA_ATTACK',
                            tick: globalTick,
                            duration: 8,
                            player: 'yama',
                            damage: 0,
                            attackType
                        });
                    }
                    
                    yamaAttackCount++;
                    yamaAttackTick += 8;
                }
                
                // Function to check if we need to start phasing
                function checkPhasing() {
                    if (!phaseEnding && yamaHP < 1675) {
                        phaseEnding = true;
                        // Find next Yama attack tick after current tick
                        let nextYamaAttack = yamaAttackTick;
                        while (nextYamaAttack <= phaseTick) {
                            nextYamaAttack += 8;
                        }
                        // Phase tick is the attack after that
                        phaseTick_final = nextYamaAttack + 8;
                        console.log(`P1 Threshold crossed at tick ${phaseTick}, next Yama attack at ${nextYamaAttack}, PHASE TICK at ${phaseTick_final}`);
                    }
                }
                
                // Can attack up until one tick before the phase tick
                const canAttack = !phaseEnding || phaseTick < phaseTick_final - 1;
                
                // Player 1 attack
                if (canAttack && phaseTick === p1Tick) {
                    let weaponType = p1AttackIndex < p1Attacks.length ? p1Attacks[p1AttackIndex] : 'EMBER';
                    
                    // Tick fill scythe: replace last hit with scythe
                    if (strategies.tickFillScythe && phaseEnding && phaseTick >= phaseTick_final - 5 && weaponType === 'EMBER') {
                        weaponType = 'SCYTHE';
                    }
                    
                    let damage = calculateDamage(weaponType, 1);
                    
                    // Half damage if already below threshold
                    if (yamaHP < 1675) {
                        damage = Math.floor(damage / 2);
                    }
                    
                    yamaHP -= damage;
                    attacks.push({
                        type: weaponType,
                        tick: globalTick,
                        duration: WEAPONS[weaponType] ? WEAPONS[weaponType].duration : (weaponType === 'ELDER_MAUL' ? 5 : 4),
                        player: 1,
                        damage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    p1AttackIndex++;
                    const weaponDuration = WEAPONS[weaponType] ? WEAPONS[weaponType].duration : (weaponType === 'ELDER_MAUL' ? 5 : 4);
                    p1Tick += weaponDuration;
                }
                
                // Player 2 attack
                if (canAttack && phaseTick === p2Tick) {
                    let weaponType = p2AttackIndex < p2Attacks.length ? p2Attacks[p2AttackIndex] : 'EMBER';
                    
                    // Handle WAIT (just advance tick, no attack)
                    if (weaponType === 'WAIT') {
                        p2AttackIndex++;
                        p2Tick += 1;
                        continue;
                    }
                    
                    // Tick fill scythe: replace last hit with scythe
                    if (strategies.tickFillScythe && phaseEnding && phaseTick >= phaseTick_final - 5 && weaponType === 'EMBER') {
                        weaponType = 'SCYTHE';
                    }
                    
                    let damage = calculateDamage(weaponType, 1);
                    
                    // Half damage if already below threshold
                    if (yamaHP < 1675) {
                        damage = Math.floor(damage / 2);
                    }
                    
                    yamaHP -= damage;
                    attacks.push({
                        type: weaponType === 'EMBER_SPECIAL' ? 'EMBER' : weaponType,
                        tick: globalTick,
                        duration: WEAPONS[weaponType === 'EMBER_SPECIAL' ? 'EMBER' : weaponType] ? WEAPONS[weaponType === 'EMBER_SPECIAL' ? 'EMBER' : weaponType].duration : 4,
                        player: 2,
                        damage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    p2AttackIndex++;
                    const actualWeapon = weaponType === 'EMBER_SPECIAL' ? 'EMBER' : weaponType;
                    const weaponDuration = WEAPONS[actualWeapon] ? WEAPONS[actualWeapon].duration : 4;
                    p2Tick += weaponDuration;
                }
                
                // Thrall attacks
                if (canAttack && phaseTick === thrallTick) {
                    let damage1 = Math.floor(Math.random() * 4);
                    let damage2 = Math.floor(Math.random() * 4);
                    let totalDamage = damage1 + damage2;
                    
                    // Half damage if already below threshold
                    if (yamaHP < 1675) {
                        totalDamage = Math.floor(totalDamage / 2);
                    }
                    
                    yamaHP -= totalDamage;
                    attacks.push({
                        type: 'THRALL',
                        tick: globalTick,
                        duration: 1,
                        player: 'thrall',
                        damage: totalDamage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    thrallTick += 4;
                }
                
                // Venge damage (only if we haven't phased yet, as venge comes from Yama's special attacks)
                if (vengeIndex < vengeTicks.length && phaseTick === vengeTicks[vengeIndex]) {
                    // Only apply venge if the corresponding special attack will actually happen
                    // Venge happens during a special attack, so if we're past phase tick, no venge
                    if (!phaseEnding || phaseTick < phaseTick_final) {
                        let vengeDamage = calculateVengeDamage(1, redFirst, vengeIndex, blueIsOrb);
                        yamaHP -= vengeDamage;
                        attacks.push({
                            type: 'VENGE',
                            tick: globalTick,
                            duration: 1,
                            player: 'venge',
                            damage: vengeDamage
                        });
                        healthHistory.push({tick: globalTick, hp: yamaHP});
                        
                        checkPhasing();
                    }
                    vengeIndex++;
                }
                
                if (phaseEnding && phaseTick >= phaseTick_final + 5) {
                    console.log(`P1 Phase ending: Phase tick was ${phaseTick_final}, ending at ${phaseTick} (should be ${phaseTick_final + 5})`);
                    break;
                }
            }
            
            return {
                endTick: globalTick + 1,
                yamaHP,
                phaseTicks: phaseTick + 1,
                gates: yamaAttackCount
            };
        }
        
        function simulatePhase2(redFirst, blueIsOrb, startTick, startHP, attacks, healthHistory) {
            let globalTick = startTick;
            let phaseTick = 0;
            let yamaHP = startHP;
            
            // Player attacks start on tick 2
            let p1Tick = 2;
            let p2Tick = 2;
            let thrallTick = 2;
            
            // Venge ticks
            const vengeTicks = [19, 43];
            let vengeIndex = 0;
            
            // Yama attacks start on tick 5
            let yamaAttackTick = 5;
            let yamaAttackCount = 0;
            
            // Both players: Player 1 starts with Ember, Player 2 starts with Burning Claw, then both continue with Embers (with possible Scythes, no ZCB in phase 2)
            let p1AttackIndex = 0;
            let p2AttackIndex = 0;
            let p1Attacks = ['EMBER'];
            let p2Attacks = ['BURNING_CLAW'];
            
            if (strategies.tickFillScythe) {
                p1Attacks = ['EMBER', 'SCYTHE', 'SCYTHE', 'SCYTHE'];
                p2Attacks = ['BURNING_CLAW', 'SCYTHE', 'SCYTHE', 'SCYTHE'];
            }
            
            let phaseEnding = false;
            let phaseTick_final = -1;
            
            for (let i = 0; i < 200; i++) {
                phaseTick = i;
                globalTick = startTick + i;
                
                // Check for Yama attack tick
                if (phaseTick === yamaAttackTick) {
                    // Only add the attack if we haven't reached the phase tick
                    if (!phaseEnding || phaseTick < phaseTick_final) {
                        const attackType = yamaAttackCount === 0 ? 'Auto' : (yamaAttackCount === 1 || yamaAttackCount === 5) ? 'Special' : 'Auto';
                        attacks.push({
                            type: 'YAMA_ATTACK',
                            tick: globalTick,
                            duration: 8,
                            player: 'yama',
                            damage: 0,
                            attackType
                        });
                    }
                    
                    yamaAttackCount++;
                    yamaAttackTick += 8;
                }
                
                // Function to check if we need to start phasing
                function checkPhasing() {
                    if (!phaseEnding && yamaHP < 850) {
                        phaseEnding = true;
                        // Find next Yama attack tick after current tick
                        let nextYamaAttack = yamaAttackTick;
                        while (nextYamaAttack <= phaseTick) {
                            nextYamaAttack += 8;
                        }
                        // Phase tick is the attack after that
                        phaseTick_final = nextYamaAttack + 8;
                        console.log(`P2 Threshold crossed at tick ${phaseTick}, next Yama attack at ${nextYamaAttack}, PHASE TICK at ${phaseTick_final}`);
                    }
                }
                
                // Can attack up until one tick before the phase tick
                const canAttack = !phaseEnding || phaseTick < phaseTick_final - 1;
                
                // Player 1 attack
                if (canAttack && phaseTick === p1Tick) {
                    let weaponType = p1AttackIndex < p1Attacks.length ? p1Attacks[p1AttackIndex] : 'EMBER';
                    
                    // Tick fill scythe: replace last hit with scythe
                    if (strategies.tickFillScythe && phaseEnding && phaseTick >= phaseTick_final - 5 && weaponType === 'EMBER') {
                        weaponType = 'SCYTHE';
                    }
                    
                    let damage = calculateDamage(weaponType, 2);
                    
                    // Half damage if already below threshold
                    if (yamaHP < 850) {
                        damage = Math.floor(damage / 2);
                    }
                    
                    yamaHP -= damage;
                    attacks.push({
                        type: weaponType,
                        tick: globalTick,
                        duration: WEAPONS[weaponType] ? WEAPONS[weaponType].duration : 4,
                        player: 1,
                        damage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    p1AttackIndex++;
                    const weaponDuration = WEAPONS[weaponType] ? WEAPONS[weaponType].duration : 4;
                    p1Tick += weaponDuration;
                }
                
                // Player 2 attack
                if (canAttack && phaseTick === p2Tick) {
                    let weaponType = p2AttackIndex < p2Attacks.length ? p2Attacks[p2AttackIndex] : 'EMBER';
                    
                    // Tick fill scythe: replace last hit with scythe
                    if (strategies.tickFillScythe && phaseEnding && phaseTick >= phaseTick_final - 5 && weaponType === 'EMBER') {
                        weaponType = 'SCYTHE';
                    }
                    
                    let damage = calculateDamage(weaponType, 2);
                    
                    // Half damage if already below threshold
                    if (yamaHP < 850) {
                        damage = Math.floor(damage / 2);
                    }
                    
                    yamaHP -= damage;
                    attacks.push({
                        type: weaponType,
                        tick: globalTick,
                        duration: WEAPONS[weaponType] ? WEAPONS[weaponType].duration : 4,
                        player: 2,
                        damage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    p2AttackIndex++;
                    const weaponDuration = WEAPONS[weaponType] ? WEAPONS[weaponType].duration : 4;
                    p2Tick += weaponDuration;
                }
                
                // Thrall attacks
                if (canAttack && phaseTick === thrallTick) {
                    let damage1 = Math.floor(Math.random() * 4);
                    let damage2 = Math.floor(Math.random() * 4);
                    let totalDamage = damage1 + damage2;
                    
                    // Half damage if already below threshold
                    if (yamaHP < 850) {
                        totalDamage = Math.floor(totalDamage / 2);
                    }
                    
                    yamaHP -= totalDamage;
                    attacks.push({
                        type: 'THRALL',
                        tick: globalTick,
                        duration: 1,
                        player: 'thrall',
                        damage: totalDamage
                    });
                    healthHistory.push({tick: globalTick, hp: yamaHP});
                    
                    checkPhasing();
                    
                    thrallTick += 4;
                }
                
                // Venge damage (only if we haven't phased yet, as venge comes from Yama's special attacks)
                if (vengeIndex < vengeTicks.length && phaseTick === vengeTicks[vengeIndex]) {
                    // Only apply venge if the corresponding special attack will actually happen
                    if (!phaseEnding || phaseTick < phaseTick_final) {
                        let vengeDamage = calculateVengeDamage(2, redFirst, vengeIndex, blueIsOrb);
                        yamaHP -= vengeDamage;
                        attacks.push({
                            type: 'VENGE',
                            tick: globalTick,
                            duration: 1,
                            player: 'venge',
                            damage: vengeDamage
                        });
                        healthHistory.push({tick: globalTick, hp: yamaHP});
                        
                        checkPhasing();
                    }
                    vengeIndex++;
                }
                
                if (phaseEnding && phaseTick >= phaseTick_final + 5) {
                    console.log(`P2 Phase ending: Phase tick was ${phaseTick_final}, ending at ${phaseTick} (should be ${phaseTick_final + 5})`);
                    break;
                }
            }
            
            return {
                endTick: globalTick + 1,
                yamaHP,
                phaseTicks: phaseTick + 1,
                gates: yamaAttackCount
            };
        }
        
        function simulatePhase3(startTick, startHP, attacks, healthHistory) {
            let yamaHP = startHP;
            
            // Initial venge damage of 20
            yamaHP -= 20;
            attacks.push({
                type: 'VENGE',
                tick: startTick,
                duration: 1,
                player: 'venge',
                damage: 20
            });
            healthHistory.push({tick: startTick, hp: yamaHP});
            
            // Player 1 attack schedule (phase-relative ticks)
            let p1Schedule = [
                {tick: 3, weapon: 'SPEAR'}
            ];
            
            // Add dragon claw after spear if D Claw strategy is enabled
            if (strategies.dClaw) {
                p1Schedule.push({tick: 8, weapon: 'DRAGON_CLAW'});
            }
            
            // Continue with embers
            const p1EmberTicks = [10, 13, 15, 19, 23, 27, 31, 34, 37, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80];
            p1EmberTicks.forEach(tick => {
                p1Schedule.push({tick, weapon: 'EMBER'});
            });
            
            // Player 2 attack schedule (phase-relative ticks)
            // Default: Burning Claw at start, unless ZCB strategy uses Dragon Claw
            let p2Schedule = [
                {tick: 5, weapon: (strategies.zcb9 || strategies.zcb10 || strategies.zcb11) ? 'DRAGON_CLAW' : 'BURNING_CLAW'},
                {tick: 9, weapon: 'EMBER'},
                {tick: 13, weapon: 'EMBER'},
                {tick: 16, weapon: 'EMBER'},
                {tick: 19, weapon: 'EMBER'},
                {tick: 23, weapon: 'EMBER'},
                {tick: 27, weapon: 'EMBER'},
                {tick: 31, weapon: 'EMBER'},
                {tick: 34, weapon: 'EMBER'},
                {tick: 37, weapon: 'EMBER'},
                {tick: 41, weapon: 'EMBER'},
                {tick: 45, weapon: 'EMBER'},
                {tick: 49, weapon: 'EMBER'},
                {tick: 53, weapon: 'EMBER'},
                {tick: 57, weapon: 'EMBER'},
                {tick: 61, weapon: 'EMBER'},
                {tick: 65, weapon: 'EMBER'},
                {tick: 69, weapon: 'EMBER'},
                {tick: 73, weapon: 'EMBER'},
                {tick: 77, weapon: 'EMBER'},
                {tick: 81, weapon: 'EMBER'}
            ];
            
            // Process all attacks
            const allEvents = [];
            p1Schedule.forEach(event => allEvents.push({...event, player: 1}));
            p2Schedule.forEach(event => allEvents.push({...event, player: 2}));
            allEvents.sort((a, b) => a.tick - b.tick);
            
            let lastTick = 0;
            for (const event of allEvents) {
                const damage = calculateDamage(event.weapon, 3);
                yamaHP -= damage;
                
                const globalTick = startTick + event.tick;
                attacks.push({
                    type: event.weapon,
                    tick: globalTick,
                    duration: event.weapon === 'SPEAR' ? 5 : (event.weapon === 'BURNING_CLAW' ? 4 : 4),
                    player: event.player,
                    damage
                });
                healthHistory.push({tick: globalTick, hp: yamaHP});
                lastTick = event.tick;
                
                if (yamaHP <= 0) {
                    return {
                        endTick: globalTick + 1,
                        yamaHP: 0,
                        phaseTicks: event.tick + 1
                    };
                }
            }
            
            // If fight doesn't end by tick 81, set to 85
            return {
                endTick: startTick + 85,
                yamaHP,
                phaseTicks: 85
            };
        }
        
        function simulateJudgePhase(startTick, attacks) {
            const judgeTicks = [
                {tick: 8, weapon: 'EYE_OF_AYAK'},
                {tick: 11, weapon: 'EMBER'},
                {tick: 15, weapon: 'EYE_OF_AYAK'},
                {tick: 18, weapon: 'ELDER_MAUL'}
            ];
            
            judgeTicks.forEach(({tick, weapon}) => {
                const damage = weapon === 'EYE_OF_AYAK' ? 35 : (weapon === 'ELDER_MAUL' ? 68 : 68);
                attacks.push({
                    type: weapon,
                    tick: startTick + tick,
                    duration: weapon === 'EYE_OF_AYAK' ? 3 : (weapon === 'ELDER_MAUL' ? 5 : 4),
                    player: 'judge',
                    damage
                });
            });
            
            return {
                endTick: startTick + 28
            };
        }
        
        function calculateDamage(weaponType, phase) {
            if (weaponType === 'EMBER_SPECIAL') {
                // Special ember that always hits max damage
                return 68;
            }
            
            if (weaponType === 'ZCB_P1') {
                // Player 1's ZCB - always hits for 110 damage
                return 110;
            }
            
            if (weaponType === 'ZCB') {
                // Player 2's ZCB - 6.6% chance to hit, always does 110 when it hits
                return Math.random() < 0.066 ? 110 : 0;
            }
            
            if (weaponType === 'BURNING_CLAW') {
                return calculateBurningClawDamage(phase);
            }
            
            if (weaponType === 'DRAGON_CLAW') {
                return calculateDragonClawDamage(phase);
            }
            
            if (weaponType === 'SCYTHE') {
                const weapon = WEAPONS.SCYTHE;
                const acc = phase === 3 ? weapon.p3Acc : weapon.p1Acc;
                let total = 0;
                for (let i = 0; i < 3; i++) {
                    if (Math.random() < acc) {
                        let dmg = Math.floor(Math.random() * (weapon.maxHit[i] + 1));
                        if (dmg === 0) dmg = 1;
                        total += dmg;
                    }
                }
                return total;
            }
            
            const weapon = WEAPONS[weaponType];
            if (!weapon) return 0;
            
            const acc = phase === 3 ? weapon.p3Acc : weapon.p1Acc;
            
            if (Math.random() < acc) {
                let dmg = Math.floor(Math.random() * (weapon.maxHit + 1));
                if (dmg === 0) dmg = 1;
                return dmg;
            }
            
            return 0;
        }
        
        function calculateBurningClawDamage(phase) {
            const maxHit = 50;
            const acc = phase === 3 ? 0.70 : 0.83;
            let totalDamage = 0;
            
            // First roll
            if (Math.random() < acc) {
                const minDmg = Math.floor(0.75 * maxHit);
                const maxDmg = Math.floor(1.75 * maxHit);
                const dmg = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;
                const h1 = Math.floor(dmg * 0.25);
                const h2 = Math.floor(dmg * 0.25);
                const h3 = dmg - h1 - h2;
                totalDamage = h1 + h2 + h3;
                // 15% chance for burn on each hitsplat
                if (Math.random() < 0.15) totalDamage += 9;
                if (Math.random() < 0.15) totalDamage += 9;
                if (Math.random() < 0.15) totalDamage += 9;
                return totalDamage;
            }
            
            // Second roll
            if (Math.random() < acc) {
                const minDmg = Math.floor(0.5 * maxHit);
                const maxDmg = Math.floor(1.5 * maxHit);
                const dmg = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;
                let h1 = Math.floor(dmg * 0.5);
                let h2 = Math.floor(dmg * 0.5);
                let h3 = dmg - h1 - h2;
                h1 = Math.max(0, h1 - 1);
                h2 = Math.max(0, h2 - 1);
                h3 += 2;
                totalDamage = h1 + h2 + h3;
                // 30% chance for burn
                if (Math.random() < 0.30) totalDamage += 9;
                if (Math.random() < 0.30) totalDamage += 9;
                if (Math.random() < 0.30) totalDamage += 9;
                return totalDamage;
            }
            
            // Third roll
            if (Math.random() < acc) {
                const minDmg = Math.floor(0.25 * maxHit);
                const maxDmg = Math.floor(1.25 * maxHit);
                const dmg = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;
                let h3 = dmg;
                h3 = Math.max(0, h3 - 2);
                let h1 = 1;
                let h2 = 1;
                totalDamage = h1 + h2 + h3;
                // 45% chance for burn
                if (Math.random() < 0.45) totalDamage += 9;
                if (Math.random() < 0.45) totalDamage += 9;
                if (Math.random() < 0.45) totalDamage += 9;
                return totalDamage;
            }
            
            // All miss
            const roll = Math.random();
            if (roll < 0.20) return 0;
            if (roll < 0.60) return 1;
            return 2;
        }
        
        function calculateDragonClawDamage(phase) {
            const maxHit = 45;
            const acc = 0.5475; // Same for all phases
            
            // Roll for each hit until one lands
            let firstHitIndex = -1;
            for (let i = 0; i < 4; i++) {
                if (Math.random() < acc) {
                    firstHitIndex = i;
                    break;
                }
            }
            
            if (firstHitIndex === -1) {
                // All four hits missed
                const missRoll = Math.random();
                if (missRoll < 0.33333) {
                    return 0; // 0-0-0-0
                } else {
                    return 2; // 2/3 chance of dealing 2 damage (1-1-0-0, etc.)
                }
            }
            
            // Calculate damage based on which hit landed first
            if (firstHitIndex === 0) {
                // 4-2-1-1 pattern
                const minHit = Math.floor(maxHit / 2);
                const maxHit1 = maxHit - 1;
                const h1 = Math.floor(Math.random() * (maxHit1 - minHit + 1)) + minHit;
                const h2 = Math.floor(h1 / 2);
                const h3 = Math.floor(h2 / 2);
                const h4 = h3 + 1;
                return h1 + h2 + h3 + h4;
            } else if (firstHitIndex === 1) {
                // 0-4-2-2 pattern
                const minHit = Math.floor(maxHit * 3 / 8);
                const maxHit2 = Math.floor(maxHit * 7 / 8);
                const h2 = Math.floor(Math.random() * (maxHit2 - minHit + 1)) + minHit;
                const h3 = Math.floor(h2 / 2);
                const h4 = h3 + 1;
                return 0 + h2 + h3 + h4;
            } else if (firstHitIndex === 2) {
                // 0-0-3-3 pattern
                const minHit = Math.floor(maxHit / 4);
                const maxHit3 = Math.floor(maxHit * 3 / 4);
                const h3 = Math.floor(Math.random() * (maxHit3 - minHit + 1)) + minHit;
                const h4 = h3 + 1;
                return 0 + 0 + h3 + h4;
            } else {
                // 0-0-0-5 pattern (firstHitIndex === 3)
                const minHit = Math.floor(maxHit / 4);
                const maxHit4 = Math.floor(maxHit * 5 / 4);
                const h4 = Math.floor(Math.random() * (maxHit4 - minHit + 1)) + minHit;
                return 0 + 0 + 0 + h4;
            }
        }
        
        function calculateVengeDamage(phase, redFirst, vengeIndex, blueIsOrb) {
            let playerDamage = 0;
            
            if (phase === 1) {
                // Phase 1 venges
                const isRed = (redFirst && vengeIndex === 0) || (!redFirst && vengeIndex === 1);
                
                if (isRed || (!blueIsOrb && !isRed)) {
                    playerDamage = Math.floor(Math.random() * 19) + 34; // 34-52
                }
            } else if (phase === 2) {
                // Phase 2 venges
                const isRed = (redFirst && vengeIndex === 0) || (!redFirst && vengeIndex === 1);
                
                if (isRed) {
                    playerDamage = 80;
                } else if (!blueIsOrb) {
                    playerDamage = Math.floor(Math.random() * 17) + 53; // 53-69
                }
            }
            
            const venge75 = Math.floor(playerDamage * 0.75);
            const venge10 = Math.floor(playerDamage * 0.10);
            return venge75 + venge10;
        }
        
        function updateStats(result) {
            document.getElementById('simCount').textContent = simCount;
            document.getElementById('currentTime').textContent = formatTicks(result.totalTicks);
            
            const avg = allTimes.reduce((a, b) => a + b, 0) / allTimes.length;
            document.getElementById('avgTime').textContent = formatTicks(Math.round(avg));
            
            const best = Math.min(...allTimes);
            document.getElementById('bestTime').textContent = formatTicks(best);
        }
        
        function formatTicks(ticks) {
            const seconds = ticks * 0.6;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const hundredths = Math.round((seconds % 1) * 100);
            return `${mins}:${secs.toString().padStart(2, '0')}.${hundredths.toString().padStart(2, '0')}`;
        }
        
        function renderTimeline(result) {
            // Clear existing blocks
            ['player-1', 'player-2', 'thralls', 'venge', 'yama-attacks'].forEach(id => {
                const row = document.getElementById(`row-${id}`);
                row.querySelectorAll('.damage-block').forEach(block => block.remove());
                row.querySelectorAll('.phase-marker').forEach(marker => marker.remove());
            });
            
            // Render phase markers
            const phases = result.phases;
            const phaseInfo = [
                {name: 'Phase 1', end: phases.phase1End},
                {name: 'Judge 1', end: phases.judge1End},
                {name: 'Phase 2', end: phases.phase2End},
                {name: 'Judge 2', end: phases.judge2End},
                {name: 'Phase 3', end: phases.phase3End}
            ];
            
            phaseInfo.forEach((phase, idx) => {
                if (idx > 0) {
                    const marker = document.createElement('div');
                    marker.className = 'phase-marker';
                    marker.style.left = (phaseInfo[idx - 1].end * TICK_WIDTH) + 'px';
                    const label = document.createElement('div');
                    label.className = 'phase-label';
                    label.textContent = phase.name;
                    marker.appendChild(label);
                    document.getElementById('row-player-1').appendChild(marker);
                }
            });
            
            // Render attacks
            result.attacks.forEach(attack => {
                const rowId = attack.player === 'yama' ? 'yama-attacks' :
                             attack.player === 'thrall' ? 'thralls' :
                             attack.player === 'venge' ? 'venge' :
                             attack.player === 'judge' ? 'player-1' :
                             `player-${attack.player}`;
                
                const row = document.getElementById(`row-${rowId}`);
                const block = document.createElement('div');
                block.className = 'damage-block';
                block.style.left = (attack.tick * TICK_WIDTH) + 'px';
                block.style.width = (attack.duration * TICK_WIDTH) + 'px';
                
                if (attack.type === 'YAMA_ATTACK') {
                    block.style.background = attack.attackType === 'Special' ? '#c0392b' : '#7f8c8d';
                    block.textContent = attack.attackType;
                } else if (attack.type === 'VENGE') {
                    block.style.background = '#9b59b6';
                    block.textContent = attack.damage;
                } else {
                    const weapon = WEAPONS[attack.type];
                    block.style.background = weapon ? weapon.color : '#555';
                    block.textContent = attack.damage;
                }
                
                row.appendChild(block);
            });
        }
        
        function renderHealthChart(result) {
            // Add to history with fading
            healthLines.push({
                history: result.healthHistory,
                opacity: 1.0
            });
            
            // Fade existing lines
            healthLines.forEach(line => {
                line.opacity = Math.max(0, line.opacity - 0.05);
            });
            
            // Remove fully faded lines
            healthLines = healthLines.filter(line => line.opacity > 0);
            
            // Clear canvas
            healthCtx.clearRect(0, 0, healthCanvas.width, healthCanvas.height);
            
            // Draw all lines
            healthLines.forEach(line => {
                healthCtx.strokeStyle = `rgba(255, 107, 53, ${line.opacity})`;
                healthCtx.lineWidth = 2;
                healthCtx.beginPath();
                
                line.history.forEach((point, i) => {
                    const x = point.tick * TICK_WIDTH;
                    const y = healthCanvas.height - (point.hp / 2500 * healthCanvas.height);
                    
                    if (i === 0) {
                        healthCtx.moveTo(x, y);
                    } else {
                        healthCtx.lineTo(x, y);
                    }
                });
                
                healthCtx.stroke();
            });
        }
        
        function updateHistograms() {
            drawHistogram('mainHistogram', allTimes);
            drawGateHistogram('sub200Phase1Histogram', sub200Phase1Gates, 'Sub 2:00 Phase 1');
            drawGateHistogram('phase1Histogram', phase1Gates, 'Phase 1');
            drawGateHistogram('phase2Histogram', phase2Gates, 'Phase 2');
            drawHistogram('phase3Histogram', phase3Times);
            drawCumulativeDistribution('cumulativeChart', allTimes);
        }
        
        function drawGateHistogram(canvasId, data, phaseLabel) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            if (data.length === 0) return;
            
            // Gates range from 3 to 9
            const minGate = 3;
            const maxGate = 9;
            const gateCount = maxGate - minGate + 1;
            
            // Create bins for each gate value
            const bins = Array(gateCount).fill(0);
            data.forEach(gates => {
                if (gates >= minGate && gates <= maxGate) {
                    bins[gates - minGate]++;
                }
            });
            
            // Convert to percentages
            const binPercentages = bins.map(count => (count / data.length) * 100);
            const maxPercent = Math.max(...binPercentages);
            
            const leftMargin = 45;
            const rightMargin = 10;
            const bottomMargin = 40;
            const topMargin = 10;
            const chartWidth = canvas.width - leftMargin - rightMargin;
            const chartHeight = canvas.height - bottomMargin - topMargin;
            const barWidth = chartWidth / gateCount;
            
            // Draw horizontal gridlines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            const percentStep = maxPercent > 50 ? 10 : (maxPercent > 20 ? 5 : 2);
            for (let pct = 0; pct <= Math.ceil(maxPercent); pct += percentStep) {
                const y = topMargin + chartHeight - (pct / Math.ceil(maxPercent)) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(leftMargin, y);
                ctx.lineTo(leftMargin + chartWidth, y);
                ctx.stroke();
            }
            
            // Draw bars
            ctx.fillStyle = '#ff6b35';
            binPercentages.forEach((percent, i) => {
                const height = (percent / Math.ceil(maxPercent)) * chartHeight;
                const x = leftMargin + i * barWidth;
                const y = topMargin + chartHeight - height;
                ctx.fillRect(x, y, barWidth - 2, height);
            });
            
            // Draw Y-axis labels (percentages)
            ctx.fillStyle = '#aaa';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let pct = 0; pct <= Math.ceil(maxPercent); pct += percentStep) {
                const y = topMargin + chartHeight - (pct / Math.ceil(maxPercent)) * chartHeight;
                ctx.fillText(pct.toFixed(0) + '%', leftMargin - 5, y);
            }
            
            // Draw X-axis labels (gate numbers 3-9)
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let gate = minGate; gate <= maxGate; gate++) {
                const x = leftMargin + (gate - minGate + 0.5) * barWidth;
                ctx.fillText(gate.toString(), x, canvas.height - bottomMargin + 5);
            }
            
            // Draw X-axis label "Gates"
            ctx.fillStyle = '#fff';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText('Gates', canvas.width / 2, canvas.height - 5);
        }
        
        function drawHistogram(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            if (data.length === 0) return;
            
            const min = Math.min(...data);
            const max = Math.max(...data);
            const binCount = 20;
            const binSize = Math.ceil((max - min + 1) / binCount);
            
            const bins = Array(binCount).fill(0);
            data.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binSize), binCount - 1);
                bins[binIndex]++;
            });
            
            // Convert to percentages
            const binPercentages = bins.map(count => (count / data.length) * 100);
            const maxPercent = Math.max(...binPercentages);
            
            const leftMargin = 45;
            const rightMargin = 10;
            const bottomMargin = 25;
            const topMargin = 10;
            const chartWidth = canvas.width - leftMargin - rightMargin;
            const chartHeight = canvas.height - bottomMargin - topMargin;
            const barWidth = chartWidth / binCount;
            
            // Draw horizontal gridlines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            const percentStep = maxPercent > 50 ? 10 : (maxPercent > 20 ? 5 : 2);
            for (let pct = 0; pct <= Math.ceil(maxPercent); pct += percentStep) {
                const y = topMargin + chartHeight - (pct / Math.ceil(maxPercent)) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(leftMargin, y);
                ctx.lineTo(leftMargin + chartWidth, y);
                ctx.stroke();
            }
            
            // Draw bars
            ctx.fillStyle = '#ff6b35';
            binPercentages.forEach((percent, i) => {
                const height = (percent / Math.ceil(maxPercent)) * chartHeight;
                const x = leftMargin + i * barWidth;
                const y = topMargin + chartHeight - height;
                ctx.fillRect(x, y, barWidth - 2, height);
            });
            
            // Draw Y-axis labels (percentages)
            ctx.fillStyle = '#aaa';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for (let pct = 0; pct <= Math.ceil(maxPercent); pct += percentStep) {
                const y = topMargin + chartHeight - (pct / Math.ceil(maxPercent)) * chartHeight;
                ctx.fillText(pct.toFixed(0) + '%', leftMargin - 5, y);
            }
            
            // Draw X-axis labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            const xLabels = [
                { value: min, x: leftMargin },
                { value: Math.floor((min + max) / 2), x: leftMargin + chartWidth / 2 },
                { value: max, x: leftMargin + chartWidth }
            ];
            
            xLabels.forEach(label => {
                ctx.fillText(label.value.toString(), label.x, canvas.height - bottomMargin + 5);
            });
        }
        
        function drawCumulativeDistribution(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            if (data.length === 0) return;
            
            // Sort data
            const sorted = [...data].sort((a, b) => a - b);
            const min = sorted[0];
            const max = sorted[sorted.length - 1];
            
            const leftMargin = 50;
            const bottomMargin = 40;
            const chartWidth = canvas.width - leftMargin - 10;
            const chartHeight = canvas.height - bottomMargin - 10;
            
            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            // Vertical grid lines (every 5 ticks)
            const tickRange = max - min;
            const tickStep = Math.max(5, Math.ceil(tickRange / 20 / 5) * 5);
            for (let tick = Math.ceil(min / tickStep) * tickStep; tick <= max; tick += tickStep) {
                const x = leftMargin + ((tick - min) / tickRange) * chartWidth;
                ctx.beginPath();
                ctx.moveTo(x, 10);
                ctx.lineTo(x, 10 + chartHeight);
                ctx.stroke();
            }
            
            // Horizontal grid lines (every 10%)
            for (let pct = 0; pct <= 100; pct += 10) {
                const y = 10 + chartHeight - (pct / 100) * chartHeight;
                ctx.beginPath();
                ctx.moveTo(leftMargin, y);
                ctx.lineTo(leftMargin + chartWidth, y);
                ctx.stroke();
            }
            
            // Calculate cumulative percentages
            const cumulativeData = [];
            for (let tick = min; tick <= max; tick++) {
                const count = sorted.filter(t => t <= tick).length;
                const percentage = (count / sorted.length) * 100;
                cumulativeData.push({ tick, percentage });
            }
            
            // Draw line
            ctx.strokeStyle = '#ff6b35';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            cumulativeData.forEach((point, i) => {
                const x = leftMargin + ((point.tick - min) / (max - min)) * chartWidth;
                const y = 10 + chartHeight - (point.percentage / 100) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw Y-axis labels (percentages)
            ctx.fillStyle = '#aaa';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'right';
            
            for (let pct = 0; pct <= 100; pct += 10) {
                const y = 10 + chartHeight - (pct / 100) * chartHeight;
                ctx.fillText(pct + '%', leftMargin - 5, y + 4);
            }
            
            // Draw X-axis labels (ticks)
            ctx.textAlign = 'center';
            for (let tick = Math.ceil(min / tickStep) * tickStep; tick <= max; tick += tickStep) {
                const x = leftMargin + ((tick - min) / tickRange) * chartWidth;
                ctx.fillText(tick.toString(), x, canvas.height - 20);
            }
            
            // Add axis titles
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillStyle = '#fff';
            ctx.font = '14px sans-serif';
            ctx.fillText('Chance to Achieve Time or Faster (%)', 0, 0);
            ctx.restore();
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.font = '14px sans-serif';
            ctx.fillText('Ticks', canvas.width / 2, canvas.height - 5);
            
            // Update table
            updateCumulativeTable(cumulativeData);
        }
        
        function updateCumulativeTable(cumulativeData) {
            const table = document.getElementById('cumulativeTable');
            
            // Keep header, remove old data rows
            while (table.children.length > 2) {
                table.removeChild(table.lastChild);
            }
            
            // Add rows for ticks 190-200
            for (let tick = 190; tick <= 200; tick++) {
                const dataPoint = cumulativeData.find(d => d.tick === tick);
                const percentage = dataPoint ? dataPoint.percentage.toFixed(2) : '-';
                
                const row = document.createElement('div');
                row.className = 'table-row';
                row.innerHTML = `<div>${tick}</div><div>${percentage}%</div>`;
                table.appendChild(row);
            }
        }
    </script>
</body>
</html>
